# Лабораторна робота №5 Бермічев Володимир ЦК-31
## Тема: 
### Алгоритми сортування

#### 1. Повторити теоретичні відомості
- 1.1. Сортування обміном (сортування бульбашкою, Bubble sort)
https://uk.wikipedia.org/wiki/Сортування_бульбашкою
https://en.wikipedia.org/wiki/Bubble_sort
- 1.2. Сортування вибором (Selection sort)
https://uk.wikipedia.org/wiki/Сортування_вибором
https://en.wikipedia.org/wiki/Selection_sort
- 1.3. Сортування включенням (сортування вставкою, Insertion sort)
https://uk.wikipedia.org/wiki/Сортування_включенням
https://en.wikipedia.org/wiki/Insertion_sort

#### 2. Реалізувати два методи сортування відповідно до свого варіанту з таблиці 1.

#### 3. Відповісти на контрольні питання

#### Умови: Варіант 2
[![image.png](https://i.postimg.cc/mZzV0wLX/image.png)](https://postimg.cc/V5wjtXbn)

#### Виконання: Код
```Java
public class Zavd2 {
    public static void selectionSort(short[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int maxIdx = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[maxIdx]) {
                    maxIdx = j;
                }
            }
            short temp = arr[maxIdx];
            arr[maxIdx] = arr[i];
            arr[i] = temp;
        }
    }

    public static void insertionSort(short[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            short key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] < key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    public static void printArray(short[] arr) {
        for (short num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        short[] arr1 = {64, 34, 25, 12, 22, 11, 90};
        short[] arr2 = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("Вихідний масив:");
        printArray(arr1);

        selectionSort(arr1);
        System.out.println("Selection Sort (за спаданням):");
        printArray(arr1);

        insertionSort(arr2);
        System.out.println("Insertion Sort (за спаданням):");
        printArray(arr2);
    }
}
```
### Результат виконання:
[![image.png](https://i.postimg.cc/2jZM4mZ2/image.png)](https://postimg.cc/dDJ5Ybny)

# Контрольні питання
## 1. Порівняйте та назвіть переваги та недоліки таких методів сортування: сортування бульбашкою, сортування вибором, сортування вставкою.
- Bubble Sort - простий, але повільний. Багато зайвих порівнянь. Єдина перевага - простота реалізації.
- Selection Sort - мінімум обмінів (O(n)), але завжди O(n^2) порівнянь. Не адаптивний.
- Insertion Sort - ефективний на частково відсортованих даних. Адаптивний. Найкращий з трьох для малих масивів.

## 2. Оцініть кожен з методів відповідно до наступних критеріїв: час роботи; потреби у додатковій пам’яті; стабільність. За якими ще критеріями ви можете порівняти ці алгоритми?
- Час роботи: Усі три алгоритми мають квадратичну складність O(n^2) у середньому та найгіршому випадках. Bubble Sort
та Insertion Sort показують лінійну складність O(n) у найкращому випадку (коли масив вже відсортований), тоді як Selection 
Sort завжди виконує O(n^2) порівнянь незалежно від вхідних даних, що робить його неадаптивним.
- Потреби у додатковій пам'яті: Всі три методи є алгоритмами сортування на місці (in-place), тобто потребують лише O(1)
додаткової пам'яті для тимчасових змінних під час обміну елементів. Жоден з них не створює копій масиву.
- Стабільність: Bubble Sort та Insertion Sort є стабільними алгоритмами - вони зберігають відносний порядок рівних 
елементів. Selection Sort не є стабільним, оскільки може змінювати порядок однакових елементів під час обміну.
- Інші критерії порівняння: кількість виконаних обмінів елементів (Selection Sort робить мінімум обмінів - O(n), 
тоді як інші можуть робити до O(n^2)), кількість порівнянь, адаптивність до частково відсортованих даних (Insertion Sort 
найкращий), простота реалізації (Bubble Sort найпростіший), практична ефективність на малих масивах (Insertion Sort часто 
швидший за інших на практиці).

## 3. Який випадок є найкращім або найгіршим для роботи цих алгоритмів? (Наприклад: частково відсортований масив або масив, відсортований у зворотному порядку). Який з методів забезпечить у цих випадках найкращій/найгірший результат?
- Найкращий для всіх: майже відсортований масив → Insertion Sort виграє (O(n))
- Найгірший для всіх: зворотний порядок → всі O(n^2), але Insertion Sort робить максимум зсувів
- Selection Sort завжди O(n^2) незалежно від вхідних даних.

## 4. Що означають позначення O(1), O(n), O(n^2)?
- O(1) - постійний час (не залежить від розміру)
- O(n) - лінійний час (пропорційний розміру)
- O(n^2) - квадратичний час (зростає як квадрат розміру)