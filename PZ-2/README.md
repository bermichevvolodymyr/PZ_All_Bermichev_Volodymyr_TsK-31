# ПЗ-2 Бермічев Володимир ЦК-31
## Тема: Оператори та типи даних
### Хід роботи
#### 1. Повторити теоретичні відомості.
#### 2. Виконати три завдання з таблиці 2 відповідно до свого варіанту у таблиці 1.
#### 3. Відповісти на контрольні питання.

## Умова:
[![pz2-tabl2.png](https://i.postimg.cc/fTS91PC8/pz2-tabl2.png)](https://postimg.cc/8jDc6tqv)
[![pz2-tabl1.png](https://i.postimg.cc/m22JTQJz/pz2-tabl1.png)](https://postimg.cc/vDk3z6Qb)
## Код
Розташован в src

```Java
public class PZ2 {
public static void main(String[] args) {
double a,b,c,d;

        a=3.56; b=1.02; c=3.0; d=2.43;
        double y1 = Math.pow(Math.tan(a), 1.0 / c)/(1+(Math.sinh(b)/(Math.abs(Math.log10(d+c)))));
        System.out.println("y1 = " + y1);

        a=2.54; b=1.23; c=-2.14; d=-0.23;
        double y2=2*Math.cos(Math.pow(a,b))+Math.abs(Math.acos(-Math.sqrt(c/d)));
        System.out.println("y2 = " + y2);

        a=-1.23; b=-0.34; c=0.707; d=2.312;
        double y3=3*(Math.log10(Math.abs(b/a))+Math.sqrt(Math.sin(c)+Math.exp(d)));
        System.out.println("y3 = " + y3);
    }
}
```
## Відповіді на контрольні питання:
## 1. В чому полягає різниця між ключовими та зарезервованими словами?
Ключові слова - це зарезервовані слова, які активно використовуються в Java і мають синтаксичне значення 
(class, if, while, public). Зарезервовані слова включають всі ключові слова плюс слова, які зарезервовані 
для майбутнього використання, але поки не мають функціональності (const, goto).

## 2. Які примітивні типи даних Ви знаєте? Для кожного з них наведіть приклади, коли найбільш ефективно використовувати саме цей тип (наприклад: довжина файлу, кількість зірок на небі, рахунок у футбольному матчі, маса всесвіту, заробітна платня, ...).
Java має 8 примітивних типів даних:
- byte (-128 до 127): Найефективніший для невеликих цілих значень а саме вік людини, рівень гучності (0-100), оцінки в школі 
(1-12), номер місяця, кількість днів у місяці. Економить пам'ять у великих масивах.
- short (-32,768 до 32,767): Оптимальний для середніх цілих значень - рік народження, висота будівлі в метрах, кількість 
працівників у компанії, номер сторінки книги, температура в Цельсіях від -273 до +32000.
int (-2.1 млрд до +2.1 млрд): Стандартний тип для більшості цілих чисел - довжина файлу в байтах, кількість пікселів на
екрані, населення міста, рахунок у футбольному матчі, заробітна плата в копійках, кількість секунд у році.
- long (-9.2×10¹⁸ до +9.2×10¹⁸): Для дуже великих чисел, такі як кількість зірок на небі, маса всесвіту в кілограмах ,
бюджет держави в копійках, кількість атомів у молекулі.
- float (32-біти, ~7 значущих цифр): Для десяткових чисел де точність не критична як температура тіла, відсотки знижки,
координати GPS з низькою точністю, швидкість автомобіля.
- double (64-біти, ~15 значущих цифр): Для високоточних обчислень - наукові розрахунки, фінансові операції з високою 
точністю, математичні константи (π, e), координати супутника.
- char (0 до 65,535): Для зберігання одного Unicode символу як літери алфавіту, цифри, спеціальні знаки, емодзі, ієрогліфи.
- boolean: Для логічних значень як статус входу користувача (увійшов/не увійшов), наявність файлу, результат порівняння, 
стан перемикача (увімкнено/вимкнено).

## 3. Що таке знакові та беззнакові типи? До якої групи відноситься кожен з примітивних типів даних?
Знакові типи це типи які можуть бути додатними і від'ємними, а беззнакові же
можуть зберігати тільки додатні. Java не має беззнакових типів. Всі цілочисельні типи (byte, short, int, long) 
є знаковими. char технічно беззнаковий 16-бітний тип для Unicode, але використовується для символів, не для арифметики.

## 4. Яке максимальне число можна записати у змінну типу short, char, int, long?
- `short`: **32 767**
- `char`: **65 535**
- `int`: **2 147 483 647**
- `long`: **9 223 372 036 854 775 807**

## 5. Змінна типу byte може приймати значення у діапазоні -128..127. Чому цей діапазон саме такий? Чому від’ємних значень більше ніж додатних?
Тип byte має діапазон -128..127 через 8-бітне представлення зі знаковим бітом. Byte займає 8 біт. Перший біт - знаковий (0=додатне, 1=від'ємне). Залишається 7 біт для значення. 
Додатні це 0 до 2⁷-1 = 127, від'ємні же використовується доповняльний код, тому -128 до -1
Від'ємних значень не більше - їх рівно стільки ж (128 додатних включно з 0, 128 від'ємних).
Загалом 256 значень (2⁸): 128 від'ємних + 128 додатних включно з нулем.

## 6. Що таке система числення? Як переводити значення з однієї у іншу?
Система числення - це спосіб позиційного представлення чисел з певною основою (базою):
Основні системи - це десяткова (основа 10, цифри 0-9), двійкова (основа 2, цифри 0-1), вісімкова (основа 8, цифри 0-7), 
шістнадцяткова (основа 16, цифри 0-9, A-F).
- Переведення у десяткову систему: розкладаємо число по степенях основи. Наприклад, 101₂ = 1×2² + 0×2¹ + 1×2⁰ = 4 + 0 +
1 = 5₁₀. Або 2A₁₆ = 2×16¹ + 10×16⁰ = 32 + 10 = 42₁₀.
- Переведення з десяткової системи: ділимо число на основу, записуючи залишки справа наліво. Наприклад, 
13₁₀ → двійкову: 13÷2=6 залишок 1, 6÷2=3 залишок 0, 3÷2=1 залишок 1, 1÷2=0 залишок 1. Читаємо знизу вгору: 1101₂.
- Між недесятковими системами: переводимо через десяткову або використовуємо групування (3 біти = 1 вісімкова цифра, 4 
біти = 1 шістнадцяткова цифра).

## 7. Що таке «доповняльний код»?
Доповняльний код - це метод представлення від'ємних чисел. Він дозволяє замість команди віднімання використовувати 
команду додавання, для знакових і беззнакових чисел. Для отримання від'ємного числа треба інвертувати всі біти 
додатного числа й додати 1.

## 8. Пояснити результат роботи такого фрагмента коду:

```Java
int a = 2_000_000_000;
int b = 2_000_000_000;
int c = a + b;
System.out.println(c);
```
[![image.png](https://i.postimg.cc/CdpSgMkw/image.png)](https://postimg.cc/QKmRg3fz)
Результат: -294967296 (переповнення з оберненням до від'ємних значень). Це через те, що розмір значення в `c` виходить за межі int.

## 9. Чим тип float відрізняється від double?
Float має 32 біти, ~7 десяткових цифр точності, double: 64 біти, ~15-17 десяткових цифр точності.
Як бачимо, різниця полягає в тому, що double точніший, займає більше пам'яті.

## 10.  Що таке число з рухомою комою? Що таке мантиса та степінь?
- Число з рухомою комою - це спосіб представлення дробових та дуже великих/малих чисел.
  Складається з трьох компонентів: знак, мантиса та степінь.
- Мантиса - це значуща частина числа. Степінь (експонента) - показник степеня основи, який визначає позицію десяткової коми.
  Наприклад: 123.45 = 1.2345 × 10²
  
## 11. Що таке Double.NaN?
NaN (Not a Number) – спецзначення `double`.
Виникає при нелегальних операціях, наприклад таких як ділення на нуль:
  - `0.0/0.0`
  - `Math.sqrt(-1)`
  - `Infinity - Infinity`

## 12. Пояснити результат роботи такого фрагменту коду:
```java
System.out.println(Double.NaN==Double.NaN);
```
Виводить false, бо NaN не дорівнює навіть самому собі

## 13.  Пояснити різницю між преінкрементом та постінкрементом. Навести приклади, коли ці операції призводять до різних результатів.
Преінкремент (++i) збільшує змінну і повертає нове значення, постінкремент (i++) повертає поточне значення і потім збільшує змінну.
До різних результатів ці випадки призводять у присвоєннях, циклах й умовах, викликах функцій, у різних складних виразах.
- Наприклад приклад з присвоєнням:
```java
int a = 5, b = 5;
int x = ++a; // x=6, a=6
int y = b++; // y=5, b=6
```
[![image.png](https://i.postimg.cc/6pLtxYxL/image.png)](https://postimg.cc/3kRPgjRd)

## 14. В чому різниця між логічною та побітовою операцією AND? Чому звичайна операція AND (&) є в обох варіантах, а її короткозамкнута версія (&&) лише тільки логічна?
- Логічна операція AND (&&) працює з boolean значеннями і має коротке замикання, побітова AND (&) працює з бітами чисел і 
завжди обчислює обидві частини.
- Чому звичайна операція AND (&) є в обох варіантах, а її короткозамкнута версія (&&) лише тільки логічна?
Коротке замикання має сенс тільки для булевої логіки, де результат можна визначити після першого операнда. Для побітових обчислень необхідно знати значення всіх бітів, тому оператор короткого замикання неможливий.
## 15. В чому різниця між OR та XOR?
OR повертає істину, якщо хоча б один з операндів істинний. XOR повертає істину тільки тоді, коли істинний рівно один 
операнд, тобто коли значення різні. Тобто, OR спрацьовує при будь-якій наявності одиниці, а XOR лише при взаємній відмінності.

## 16. Проаналізувати наступний фрагмент програми. Передбачити його результат. Запустити. Пояснити.

```java
boolean a = true && false | false;
System.out.println(a = false);

boolean b = true && false || false;
System.out.println(b = true);
```
- Передбачення
1. `true && false | false` -> `(true && false) | false` -> `false | false` -> `false`
2. `a = false` (присвоєння) -> виводиться `false`
3. `true && false || false` -> `(true && false) || false` → `false || false` → `false`
4. `b = true` (присвоєння) -> виводиться `true`

- Результат

[![image.png](https://i.postimg.cc/N086Ty2k/image.png)](https://postimg.cc/p9T5MLZm)

- Пояснення.
Перші присвоєння (a = false, b = false) ігноруються операторами присвоєння в println. Оператор присвоєння (=) повертає
присвоєне значення, тому a = false повертає false, а b = true повертає true незалежно від попередніх значень змінних.
Ключовий момент: різниця між | (побітове OR) та || (логічне OR з коротким замиканням) тут не впливає на результат, 
скільки обидва операнди false. Головне - це операції присвоєння в println, які перезаписують попередні значення.
